// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FpdLogMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "FpdLogMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace FpdLogMessage {

void protobuf_ShutdownFile_FpdLogMessage_2eproto() {
  delete Vector::default_instance_;
  delete GlobalEventLog::default_instance_;
  delete SystemOptionLog::default_instance_;
  delete SystemOptionLog_Game_option_setting::default_instance_;
  delete SystemOptionLog_Network_setting::default_instance_;
  delete UseItemLog::default_instance_;
  delete UseItemLog_Use_item_info_list::default_instance_;
  delete GetItemLog::default_instance_;
  delete GetItemLog_Get_item_info_list::default_instance_;
  delete ActGestureLog::default_instance_;
  delete ActGestureLog_Use_gesture_info_list::default_instance_;
  delete LevelUpLog::default_instance_;
  delete UseMagicLog::default_instance_;
  delete UseMagicLog_Use_magic_info_list::default_instance_;
  delete BrokenEquipmentLog::default_instance_;
  delete PurchaseItemLog::default_instance_;
  delete PurchaseItemLog_Purchase_item_info_list::default_instance_;
  delete DropItemLog::default_instance_;
  delete DropItemLog_Throw_away_item_list::default_instance_;
  delete LeaveItemLog::default_instance_;
  delete LeaveItemLog_Set_item_info_list::default_instance_;
  delete SaleItemLog::default_instance_;
  delete SaleItemLog_Sale_item_info_list::default_instance_;
  delete AccessWarehouseLog::default_instance_;
  delete AccessWarehouseLog_Access_warehouse_info_list::default_instance_;
  delete StrengthenWeaponLog::default_instance_;
  delete StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_;
  delete RepairEquipmentLog::default_instance_;
  delete RepairEquipmentLog_Repair_equipment_info_list::default_instance_;
  delete EquipMagicLog::default_instance_;
  delete ChaneEstusFlaskNumLog::default_instance_;
  delete CreateBloodMessageLog::default_instance_;
  delete EvaluateBloodMessageLog::default_instance_;
  delete VisitResultLog::default_instance_;
  delete QuickMatchResultLog::default_instance_;
  delete QuickMatchEndLog::default_instance_;
  delete ConvertSaveDataLog::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_FpdLogMessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_FpdLogMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Vector::default_instance_ = new Vector();
  GlobalEventLog::default_instance_ = new GlobalEventLog();
  SystemOptionLog::default_instance_ = new SystemOptionLog();
  SystemOptionLog_Game_option_setting::default_instance_ = new SystemOptionLog_Game_option_setting();
  SystemOptionLog_Network_setting::default_instance_ = new SystemOptionLog_Network_setting();
  UseItemLog::default_instance_ = new UseItemLog();
  UseItemLog_Use_item_info_list::default_instance_ = new UseItemLog_Use_item_info_list();
  GetItemLog::default_instance_ = new GetItemLog();
  GetItemLog_Get_item_info_list::default_instance_ = new GetItemLog_Get_item_info_list();
  ActGestureLog::default_instance_ = new ActGestureLog();
  ActGestureLog_Use_gesture_info_list::default_instance_ = new ActGestureLog_Use_gesture_info_list();
  LevelUpLog::default_instance_ = new LevelUpLog();
  UseMagicLog::default_instance_ = new UseMagicLog();
  UseMagicLog_Use_magic_info_list::default_instance_ = new UseMagicLog_Use_magic_info_list();
  BrokenEquipmentLog::default_instance_ = new BrokenEquipmentLog();
  PurchaseItemLog::default_instance_ = new PurchaseItemLog();
  PurchaseItemLog_Purchase_item_info_list::default_instance_ = new PurchaseItemLog_Purchase_item_info_list();
  DropItemLog::default_instance_ = new DropItemLog();
  DropItemLog_Throw_away_item_list::default_instance_ = new DropItemLog_Throw_away_item_list();
  LeaveItemLog::default_instance_ = new LeaveItemLog();
  LeaveItemLog_Set_item_info_list::default_instance_ = new LeaveItemLog_Set_item_info_list();
  SaleItemLog::default_instance_ = new SaleItemLog();
  SaleItemLog_Sale_item_info_list::default_instance_ = new SaleItemLog_Sale_item_info_list();
  AccessWarehouseLog::default_instance_ = new AccessWarehouseLog();
  AccessWarehouseLog_Access_warehouse_info_list::default_instance_ = new AccessWarehouseLog_Access_warehouse_info_list();
  StrengthenWeaponLog::default_instance_ = new StrengthenWeaponLog();
  StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_ = new StrengthenWeaponLog_Strengthen_weapon_info_list();
  RepairEquipmentLog::default_instance_ = new RepairEquipmentLog();
  RepairEquipmentLog_Repair_equipment_info_list::default_instance_ = new RepairEquipmentLog_Repair_equipment_info_list();
  EquipMagicLog::default_instance_ = new EquipMagicLog();
  ChaneEstusFlaskNumLog::default_instance_ = new ChaneEstusFlaskNumLog();
  CreateBloodMessageLog::default_instance_ = new CreateBloodMessageLog();
  EvaluateBloodMessageLog::default_instance_ = new EvaluateBloodMessageLog();
  VisitResultLog::default_instance_ = new VisitResultLog();
  QuickMatchResultLog::default_instance_ = new QuickMatchResultLog();
  QuickMatchEndLog::default_instance_ = new QuickMatchEndLog();
  ConvertSaveDataLog::default_instance_ = new ConvertSaveDataLog();
  Vector::default_instance_->InitAsDefaultInstance();
  GlobalEventLog::default_instance_->InitAsDefaultInstance();
  SystemOptionLog::default_instance_->InitAsDefaultInstance();
  SystemOptionLog_Game_option_setting::default_instance_->InitAsDefaultInstance();
  SystemOptionLog_Network_setting::default_instance_->InitAsDefaultInstance();
  UseItemLog::default_instance_->InitAsDefaultInstance();
  UseItemLog_Use_item_info_list::default_instance_->InitAsDefaultInstance();
  GetItemLog::default_instance_->InitAsDefaultInstance();
  GetItemLog_Get_item_info_list::default_instance_->InitAsDefaultInstance();
  ActGestureLog::default_instance_->InitAsDefaultInstance();
  ActGestureLog_Use_gesture_info_list::default_instance_->InitAsDefaultInstance();
  LevelUpLog::default_instance_->InitAsDefaultInstance();
  UseMagicLog::default_instance_->InitAsDefaultInstance();
  UseMagicLog_Use_magic_info_list::default_instance_->InitAsDefaultInstance();
  BrokenEquipmentLog::default_instance_->InitAsDefaultInstance();
  PurchaseItemLog::default_instance_->InitAsDefaultInstance();
  PurchaseItemLog_Purchase_item_info_list::default_instance_->InitAsDefaultInstance();
  DropItemLog::default_instance_->InitAsDefaultInstance();
  DropItemLog_Throw_away_item_list::default_instance_->InitAsDefaultInstance();
  LeaveItemLog::default_instance_->InitAsDefaultInstance();
  LeaveItemLog_Set_item_info_list::default_instance_->InitAsDefaultInstance();
  SaleItemLog::default_instance_->InitAsDefaultInstance();
  SaleItemLog_Sale_item_info_list::default_instance_->InitAsDefaultInstance();
  AccessWarehouseLog::default_instance_->InitAsDefaultInstance();
  AccessWarehouseLog_Access_warehouse_info_list::default_instance_->InitAsDefaultInstance();
  StrengthenWeaponLog::default_instance_->InitAsDefaultInstance();
  StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_->InitAsDefaultInstance();
  RepairEquipmentLog::default_instance_->InitAsDefaultInstance();
  RepairEquipmentLog_Repair_equipment_info_list::default_instance_->InitAsDefaultInstance();
  EquipMagicLog::default_instance_->InitAsDefaultInstance();
  ChaneEstusFlaskNumLog::default_instance_->InitAsDefaultInstance();
  CreateBloodMessageLog::default_instance_->InitAsDefaultInstance();
  EvaluateBloodMessageLog::default_instance_->InitAsDefaultInstance();
  VisitResultLog::default_instance_->InitAsDefaultInstance();
  QuickMatchResultLog::default_instance_->InitAsDefaultInstance();
  QuickMatchEndLog::default_instance_->InitAsDefaultInstance();
  ConvertSaveDataLog::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_FpdLogMessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_FpdLogMessage_2eproto_once_);
void protobuf_AddDesc_FpdLogMessage_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_FpdLogMessage_2eproto_once_,
                 &protobuf_AddDesc_FpdLogMessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_FpdLogMessage_2eproto {
  StaticDescriptorInitializer_FpdLogMessage_2eproto() {
    protobuf_AddDesc_FpdLogMessage_2eproto();
  }
} static_descriptor_initializer_FpdLogMessage_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Vector::Vector()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.Vector)
}

void Vector::InitAsDefaultInstance() {
}

Vector::Vector(const Vector& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.Vector)
}

void Vector::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vector::~Vector() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.Vector)
  SharedDtor();
}

void Vector::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Vector::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Vector& Vector::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

Vector* Vector::default_instance_ = NULL;

Vector* Vector::New() const {
  return new Vector;
}

void Vector::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool Vector::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.Vector)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.Vector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.Vector)
  return false;
#undef DO_
}

void Vector::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.Vector)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.Vector)
}

int Vector::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vector::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Vector*>(&from));
}

void Vector::MergeFrom(const Vector& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void Vector::CopyFrom(const Vector& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {

  return true;
}

void Vector::Swap(Vector* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Vector::GetTypeName() const {
  return "FpdLogMessage.Vector";
}


// ===================================================================

#ifndef _MSC_VER
const int GlobalEventLog::kValuesFieldNumber;
#endif  // !_MSC_VER

GlobalEventLog::GlobalEventLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.GlobalEventLog)
}

void GlobalEventLog::InitAsDefaultInstance() {
}

GlobalEventLog::GlobalEventLog(const GlobalEventLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.GlobalEventLog)
}

void GlobalEventLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GlobalEventLog::~GlobalEventLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.GlobalEventLog)
  SharedDtor();
}

void GlobalEventLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GlobalEventLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GlobalEventLog& GlobalEventLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GlobalEventLog* GlobalEventLog::default_instance_ = NULL;

GlobalEventLog* GlobalEventLog::New() const {
  return new GlobalEventLog;
}

void GlobalEventLog::Clear() {
  values_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GlobalEventLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.GlobalEventLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 values = 1;
      case 1: {
        if (tag == 8) {
         parse_values:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_values())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_values())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_values;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.GlobalEventLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.GlobalEventLog)
  return false;
#undef DO_
}

void GlobalEventLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.GlobalEventLog)
  // repeated uint32 values = 1;
  for (int i = 0; i < this->values_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->values(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.GlobalEventLog)
}

int GlobalEventLog::ByteSize() const {
  int total_size = 0;

  // repeated uint32 values = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->values_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->values(i));
    }
    total_size += 1 * this->values_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GlobalEventLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GlobalEventLog*>(&from));
}

void GlobalEventLog::MergeFrom(const GlobalEventLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  values_.MergeFrom(from.values_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GlobalEventLog::CopyFrom(const GlobalEventLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalEventLog::IsInitialized() const {

  return true;
}

void GlobalEventLog::Swap(GlobalEventLog* other) {
  if (other != this) {
    values_.Swap(&other->values_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GlobalEventLog::GetTypeName() const {
  return "FpdLogMessage.GlobalEventLog";
}


// ===================================================================

#ifndef _MSC_VER
const int SystemOptionLog_Game_option_setting::kUnknown1FieldNumber;
const int SystemOptionLog_Game_option_setting::kUnknown2FieldNumber;
const int SystemOptionLog_Game_option_setting::kUnknown3FieldNumber;
const int SystemOptionLog_Game_option_setting::kUnknown4FieldNumber;
const int SystemOptionLog_Game_option_setting::kUnknown5FieldNumber;
#endif  // !_MSC_VER

SystemOptionLog_Game_option_setting::SystemOptionLog_Game_option_setting()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.SystemOptionLog.Game_option_setting)
}

void SystemOptionLog_Game_option_setting::InitAsDefaultInstance() {
}

SystemOptionLog_Game_option_setting::SystemOptionLog_Game_option_setting(const SystemOptionLog_Game_option_setting& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.SystemOptionLog.Game_option_setting)
}

void SystemOptionLog_Game_option_setting::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog_Game_option_setting::~SystemOptionLog_Game_option_setting() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.SystemOptionLog.Game_option_setting)
  SharedDtor();
}

void SystemOptionLog_Game_option_setting::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SystemOptionLog_Game_option_setting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog_Game_option_setting& SystemOptionLog_Game_option_setting::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog_Game_option_setting* SystemOptionLog_Game_option_setting::default_instance_ = NULL;

SystemOptionLog_Game_option_setting* SystemOptionLog_Game_option_setting::New() const {
  return new SystemOptionLog_Game_option_setting;
}

void SystemOptionLog_Game_option_setting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SystemOptionLog_Game_option_setting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(unknown_1_, unknown_5_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog_Game_option_setting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.SystemOptionLog.Game_option_setting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 3;
      case 3: {
        if (tag == 24) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 4;
      case 4: {
        if (tag == 32) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 5;
      case 5: {
        if (tag == 40) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 6;
      case 6: {
        if (tag == 48) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.SystemOptionLog.Game_option_setting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.SystemOptionLog.Game_option_setting)
  return false;
#undef DO_
}

void SystemOptionLog_Game_option_setting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.SystemOptionLog.Game_option_setting)
  // required uint32 unknown_1 = 2;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 3;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 4;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 5;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 6;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->unknown_5(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.SystemOptionLog.Game_option_setting)
}

int SystemOptionLog_Game_option_setting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 2;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 3;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 4;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 5;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 6;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog_Game_option_setting::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog_Game_option_setting*>(&from));
}

void SystemOptionLog_Game_option_setting::MergeFrom(const SystemOptionLog_Game_option_setting& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog_Game_option_setting::CopyFrom(const SystemOptionLog_Game_option_setting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog_Game_option_setting::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void SystemOptionLog_Game_option_setting::Swap(SystemOptionLog_Game_option_setting* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog_Game_option_setting::GetTypeName() const {
  return "FpdLogMessage.SystemOptionLog.Game_option_setting";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SystemOptionLog_Network_setting::kUnknown1FieldNumber;
const int SystemOptionLog_Network_setting::kUnknown2FieldNumber;
const int SystemOptionLog_Network_setting::kUnknown3FieldNumber;
const int SystemOptionLog_Network_setting::kUnknown4FieldNumber;
const int SystemOptionLog_Network_setting::kUnknown5FieldNumber;
const int SystemOptionLog_Network_setting::kUnknown6FieldNumber;
#endif  // !_MSC_VER

SystemOptionLog_Network_setting::SystemOptionLog_Network_setting()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.SystemOptionLog.Network_setting)
}

void SystemOptionLog_Network_setting::InitAsDefaultInstance() {
}

SystemOptionLog_Network_setting::SystemOptionLog_Network_setting(const SystemOptionLog_Network_setting& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.SystemOptionLog.Network_setting)
}

void SystemOptionLog_Network_setting::SharedCtor() {
  _cached_size_ = 0;
  unknown_1_ = 0u;
  unknown_2_ = 0u;
  unknown_3_ = 0u;
  unknown_4_ = 0u;
  unknown_5_ = 0u;
  unknown_6_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog_Network_setting::~SystemOptionLog_Network_setting() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.SystemOptionLog.Network_setting)
  SharedDtor();
}

void SystemOptionLog_Network_setting::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SystemOptionLog_Network_setting::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog_Network_setting& SystemOptionLog_Network_setting::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog_Network_setting* SystemOptionLog_Network_setting::default_instance_ = NULL;

SystemOptionLog_Network_setting* SystemOptionLog_Network_setting::New() const {
  return new SystemOptionLog_Network_setting;
}

void SystemOptionLog_Network_setting::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SystemOptionLog_Network_setting*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(unknown_1_, unknown_6_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog_Network_setting::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.SystemOptionLog.Network_setting)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 unknown_1 = 8;
      case 8: {
        if (tag == 64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_1_)));
          set_has_unknown_1();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_unknown_2;
        break;
      }

      // required uint32 unknown_2 = 9;
      case 9: {
        if (tag == 72) {
         parse_unknown_2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_2_)));
          set_has_unknown_2();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_unknown_3;
        break;
      }

      // required uint32 unknown_3 = 10;
      case 10: {
        if (tag == 80) {
         parse_unknown_3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_3_)));
          set_has_unknown_3();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_unknown_4;
        break;
      }

      // required uint32 unknown_4 = 11;
      case 11: {
        if (tag == 88) {
         parse_unknown_4:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_4_)));
          set_has_unknown_4();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_unknown_5;
        break;
      }

      // required uint32 unknown_5 = 12;
      case 12: {
        if (tag == 96) {
         parse_unknown_5:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_5_)));
          set_has_unknown_5();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_unknown_6;
        break;
      }

      // required uint32 unknown_6 = 13;
      case 13: {
        if (tag == 104) {
         parse_unknown_6:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unknown_6_)));
          set_has_unknown_6();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.SystemOptionLog.Network_setting)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.SystemOptionLog.Network_setting)
  return false;
#undef DO_
}

void SystemOptionLog_Network_setting::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.SystemOptionLog.Network_setting)
  // required uint32 unknown_1 = 8;
  if (has_unknown_1()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->unknown_1(), output);
  }

  // required uint32 unknown_2 = 9;
  if (has_unknown_2()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->unknown_2(), output);
  }

  // required uint32 unknown_3 = 10;
  if (has_unknown_3()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->unknown_3(), output);
  }

  // required uint32 unknown_4 = 11;
  if (has_unknown_4()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->unknown_4(), output);
  }

  // required uint32 unknown_5 = 12;
  if (has_unknown_5()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->unknown_5(), output);
  }

  // required uint32 unknown_6 = 13;
  if (has_unknown_6()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->unknown_6(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.SystemOptionLog.Network_setting)
}

int SystemOptionLog_Network_setting::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 unknown_1 = 8;
    if (has_unknown_1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_1());
    }

    // required uint32 unknown_2 = 9;
    if (has_unknown_2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_2());
    }

    // required uint32 unknown_3 = 10;
    if (has_unknown_3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_3());
    }

    // required uint32 unknown_4 = 11;
    if (has_unknown_4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_4());
    }

    // required uint32 unknown_5 = 12;
    if (has_unknown_5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_5());
    }

    // required uint32 unknown_6 = 13;
    if (has_unknown_6()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unknown_6());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog_Network_setting::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog_Network_setting*>(&from));
}

void SystemOptionLog_Network_setting::MergeFrom(const SystemOptionLog_Network_setting& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_unknown_1()) {
      set_unknown_1(from.unknown_1());
    }
    if (from.has_unknown_2()) {
      set_unknown_2(from.unknown_2());
    }
    if (from.has_unknown_3()) {
      set_unknown_3(from.unknown_3());
    }
    if (from.has_unknown_4()) {
      set_unknown_4(from.unknown_4());
    }
    if (from.has_unknown_5()) {
      set_unknown_5(from.unknown_5());
    }
    if (from.has_unknown_6()) {
      set_unknown_6(from.unknown_6());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog_Network_setting::CopyFrom(const SystemOptionLog_Network_setting& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog_Network_setting::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void SystemOptionLog_Network_setting::Swap(SystemOptionLog_Network_setting* other) {
  if (other != this) {
    std::swap(unknown_1_, other->unknown_1_);
    std::swap(unknown_2_, other->unknown_2_);
    std::swap(unknown_3_, other->unknown_3_);
    std::swap(unknown_4_, other->unknown_4_);
    std::swap(unknown_5_, other->unknown_5_);
    std::swap(unknown_6_, other->unknown_6_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog_Network_setting::GetTypeName() const {
  return "FpdLogMessage.SystemOptionLog.Network_setting";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SystemOptionLog::kGameSettingsFieldNumber;
const int SystemOptionLog::kNetworkSettingsFieldNumber;
#endif  // !_MSC_VER

SystemOptionLog::SystemOptionLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.SystemOptionLog)
}

void SystemOptionLog::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  game_settings_ = const_cast< ::FpdLogMessage::SystemOptionLog_Game_option_setting*>(
      ::FpdLogMessage::SystemOptionLog_Game_option_setting::internal_default_instance());
#else
  game_settings_ = const_cast< ::FpdLogMessage::SystemOptionLog_Game_option_setting*>(&::FpdLogMessage::SystemOptionLog_Game_option_setting::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  network_settings_ = const_cast< ::FpdLogMessage::SystemOptionLog_Network_setting*>(
      ::FpdLogMessage::SystemOptionLog_Network_setting::internal_default_instance());
#else
  network_settings_ = const_cast< ::FpdLogMessage::SystemOptionLog_Network_setting*>(&::FpdLogMessage::SystemOptionLog_Network_setting::default_instance());
#endif
}

SystemOptionLog::SystemOptionLog(const SystemOptionLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.SystemOptionLog)
}

void SystemOptionLog::SharedCtor() {
  _cached_size_ = 0;
  game_settings_ = NULL;
  network_settings_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemOptionLog::~SystemOptionLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.SystemOptionLog)
  SharedDtor();
}

void SystemOptionLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete game_settings_;
    delete network_settings_;
  }
}

void SystemOptionLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemOptionLog& SystemOptionLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SystemOptionLog* SystemOptionLog::default_instance_ = NULL;

SystemOptionLog* SystemOptionLog::New() const {
  return new SystemOptionLog;
}

void SystemOptionLog::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_game_settings()) {
      if (game_settings_ != NULL) game_settings_->::FpdLogMessage::SystemOptionLog_Game_option_setting::Clear();
    }
    if (has_network_settings()) {
      if (network_settings_ != NULL) network_settings_->::FpdLogMessage::SystemOptionLog_Network_setting::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SystemOptionLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.SystemOptionLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_game_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_network_settings;
        break;
      }

      // required .FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
      case 7: {
        if (tag == 58) {
         parse_network_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_network_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.SystemOptionLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.SystemOptionLog)
  return false;
#undef DO_
}

void SystemOptionLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.SystemOptionLog)
  // required .FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
  if (has_game_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->game_settings(), output);
  }

  // required .FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
  if (has_network_settings()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->network_settings(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.SystemOptionLog)
}

int SystemOptionLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .FpdLogMessage.SystemOptionLog.Game_option_setting game_settings = 1;
    if (has_game_settings()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->game_settings());
    }

    // required .FpdLogMessage.SystemOptionLog.Network_setting network_settings = 7;
    if (has_network_settings()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->network_settings());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemOptionLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemOptionLog*>(&from));
}

void SystemOptionLog::MergeFrom(const SystemOptionLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_game_settings()) {
      mutable_game_settings()->::FpdLogMessage::SystemOptionLog_Game_option_setting::MergeFrom(from.game_settings());
    }
    if (from.has_network_settings()) {
      mutable_network_settings()->::FpdLogMessage::SystemOptionLog_Network_setting::MergeFrom(from.network_settings());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SystemOptionLog::CopyFrom(const SystemOptionLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemOptionLog::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_game_settings()) {
    if (!this->game_settings().IsInitialized()) return false;
  }
  if (has_network_settings()) {
    if (!this->network_settings().IsInitialized()) return false;
  }
  return true;
}

void SystemOptionLog::Swap(SystemOptionLog* other) {
  if (other != this) {
    std::swap(game_settings_, other->game_settings_);
    std::swap(network_settings_, other->network_settings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SystemOptionLog::GetTypeName() const {
  return "FpdLogMessage.SystemOptionLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UseItemLog_Use_item_info_list::UseItemLog_Use_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.UseItemLog.Use_item_info_list)
}

void UseItemLog_Use_item_info_list::InitAsDefaultInstance() {
}

UseItemLog_Use_item_info_list::UseItemLog_Use_item_info_list(const UseItemLog_Use_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.UseItemLog.Use_item_info_list)
}

void UseItemLog_Use_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseItemLog_Use_item_info_list::~UseItemLog_Use_item_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.UseItemLog.Use_item_info_list)
  SharedDtor();
}

void UseItemLog_Use_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseItemLog_Use_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseItemLog_Use_item_info_list& UseItemLog_Use_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseItemLog_Use_item_info_list* UseItemLog_Use_item_info_list::default_instance_ = NULL;

UseItemLog_Use_item_info_list* UseItemLog_Use_item_info_list::New() const {
  return new UseItemLog_Use_item_info_list;
}

void UseItemLog_Use_item_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseItemLog_Use_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.UseItemLog.Use_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.UseItemLog.Use_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.UseItemLog.Use_item_info_list)
  return false;
#undef DO_
}

void UseItemLog_Use_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.UseItemLog.Use_item_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.UseItemLog.Use_item_info_list)
}

int UseItemLog_Use_item_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseItemLog_Use_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseItemLog_Use_item_info_list*>(&from));
}

void UseItemLog_Use_item_info_list::MergeFrom(const UseItemLog_Use_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseItemLog_Use_item_info_list::CopyFrom(const UseItemLog_Use_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseItemLog_Use_item_info_list::IsInitialized() const {

  return true;
}

void UseItemLog_Use_item_info_list::Swap(UseItemLog_Use_item_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseItemLog_Use_item_info_list::GetTypeName() const {
  return "FpdLogMessage.UseItemLog.Use_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

UseItemLog::UseItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.UseItemLog)
}

void UseItemLog::InitAsDefaultInstance() {
}

UseItemLog::UseItemLog(const UseItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.UseItemLog)
}

void UseItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseItemLog::~UseItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.UseItemLog)
  SharedDtor();
}

void UseItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseItemLog& UseItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseItemLog* UseItemLog::default_instance_ = NULL;

UseItemLog* UseItemLog::New() const {
  return new UseItemLog;
}

void UseItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.UseItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.UseItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.UseItemLog)
  return false;
#undef DO_
}

void UseItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.UseItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.UseItemLog)
}

int UseItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseItemLog*>(&from));
}

void UseItemLog::MergeFrom(const UseItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseItemLog::CopyFrom(const UseItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseItemLog::IsInitialized() const {

  return true;
}

void UseItemLog::Swap(UseItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseItemLog::GetTypeName() const {
  return "FpdLogMessage.UseItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetItemLog_Get_item_info_list::GetItemLog_Get_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.GetItemLog.Get_item_info_list)
}

void GetItemLog_Get_item_info_list::InitAsDefaultInstance() {
}

GetItemLog_Get_item_info_list::GetItemLog_Get_item_info_list(const GetItemLog_Get_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.GetItemLog.Get_item_info_list)
}

void GetItemLog_Get_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetItemLog_Get_item_info_list::~GetItemLog_Get_item_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.GetItemLog.Get_item_info_list)
  SharedDtor();
}

void GetItemLog_Get_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetItemLog_Get_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetItemLog_Get_item_info_list& GetItemLog_Get_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GetItemLog_Get_item_info_list* GetItemLog_Get_item_info_list::default_instance_ = NULL;

GetItemLog_Get_item_info_list* GetItemLog_Get_item_info_list::New() const {
  return new GetItemLog_Get_item_info_list;
}

void GetItemLog_Get_item_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetItemLog_Get_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.GetItemLog.Get_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.GetItemLog.Get_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.GetItemLog.Get_item_info_list)
  return false;
#undef DO_
}

void GetItemLog_Get_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.GetItemLog.Get_item_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.GetItemLog.Get_item_info_list)
}

int GetItemLog_Get_item_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetItemLog_Get_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetItemLog_Get_item_info_list*>(&from));
}

void GetItemLog_Get_item_info_list::MergeFrom(const GetItemLog_Get_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetItemLog_Get_item_info_list::CopyFrom(const GetItemLog_Get_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetItemLog_Get_item_info_list::IsInitialized() const {

  return true;
}

void GetItemLog_Get_item_info_list::Swap(GetItemLog_Get_item_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetItemLog_Get_item_info_list::GetTypeName() const {
  return "FpdLogMessage.GetItemLog.Get_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetItemLog::GetItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.GetItemLog)
}

void GetItemLog::InitAsDefaultInstance() {
}

GetItemLog::GetItemLog(const GetItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.GetItemLog)
}

void GetItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetItemLog::~GetItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.GetItemLog)
  SharedDtor();
}

void GetItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetItemLog& GetItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

GetItemLog* GetItemLog::default_instance_ = NULL;

GetItemLog* GetItemLog::New() const {
  return new GetItemLog;
}

void GetItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.GetItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.GetItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.GetItemLog)
  return false;
#undef DO_
}

void GetItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.GetItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.GetItemLog)
}

int GetItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetItemLog*>(&from));
}

void GetItemLog::MergeFrom(const GetItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetItemLog::CopyFrom(const GetItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetItemLog::IsInitialized() const {

  return true;
}

void GetItemLog::Swap(GetItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetItemLog::GetTypeName() const {
  return "FpdLogMessage.GetItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ActGestureLog_Use_gesture_info_list::ActGestureLog_Use_gesture_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

void ActGestureLog_Use_gesture_info_list::InitAsDefaultInstance() {
}

ActGestureLog_Use_gesture_info_list::ActGestureLog_Use_gesture_info_list(const ActGestureLog_Use_gesture_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

void ActGestureLog_Use_gesture_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActGestureLog_Use_gesture_info_list::~ActGestureLog_Use_gesture_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  SharedDtor();
}

void ActGestureLog_Use_gesture_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActGestureLog_Use_gesture_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActGestureLog_Use_gesture_info_list& ActGestureLog_Use_gesture_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ActGestureLog_Use_gesture_info_list* ActGestureLog_Use_gesture_info_list::default_instance_ = NULL;

ActGestureLog_Use_gesture_info_list* ActGestureLog_Use_gesture_info_list::New() const {
  return new ActGestureLog_Use_gesture_info_list;
}

void ActGestureLog_Use_gesture_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ActGestureLog_Use_gesture_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  return false;
#undef DO_
}

void ActGestureLog_Use_gesture_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.ActGestureLog.Use_gesture_info_list)
}

int ActGestureLog_Use_gesture_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActGestureLog_Use_gesture_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActGestureLog_Use_gesture_info_list*>(&from));
}

void ActGestureLog_Use_gesture_info_list::MergeFrom(const ActGestureLog_Use_gesture_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ActGestureLog_Use_gesture_info_list::CopyFrom(const ActGestureLog_Use_gesture_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActGestureLog_Use_gesture_info_list::IsInitialized() const {

  return true;
}

void ActGestureLog_Use_gesture_info_list::Swap(ActGestureLog_Use_gesture_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActGestureLog_Use_gesture_info_list::GetTypeName() const {
  return "FpdLogMessage.ActGestureLog.Use_gesture_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

ActGestureLog::ActGestureLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.ActGestureLog)
}

void ActGestureLog::InitAsDefaultInstance() {
}

ActGestureLog::ActGestureLog(const ActGestureLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.ActGestureLog)
}

void ActGestureLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActGestureLog::~ActGestureLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.ActGestureLog)
  SharedDtor();
}

void ActGestureLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActGestureLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActGestureLog& ActGestureLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ActGestureLog* ActGestureLog::default_instance_ = NULL;

ActGestureLog* ActGestureLog::New() const {
  return new ActGestureLog;
}

void ActGestureLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ActGestureLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.ActGestureLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.ActGestureLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.ActGestureLog)
  return false;
#undef DO_
}

void ActGestureLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.ActGestureLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.ActGestureLog)
}

int ActGestureLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActGestureLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActGestureLog*>(&from));
}

void ActGestureLog::MergeFrom(const ActGestureLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ActGestureLog::CopyFrom(const ActGestureLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActGestureLog::IsInitialized() const {

  return true;
}

void ActGestureLog::Swap(ActGestureLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ActGestureLog::GetTypeName() const {
  return "FpdLogMessage.ActGestureLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LevelUpLog::LevelUpLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.LevelUpLog)
}

void LevelUpLog::InitAsDefaultInstance() {
}

LevelUpLog::LevelUpLog(const LevelUpLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.LevelUpLog)
}

void LevelUpLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LevelUpLog::~LevelUpLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.LevelUpLog)
  SharedDtor();
}

void LevelUpLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LevelUpLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LevelUpLog& LevelUpLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LevelUpLog* LevelUpLog::default_instance_ = NULL;

LevelUpLog* LevelUpLog::New() const {
  return new LevelUpLog;
}

void LevelUpLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LevelUpLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.LevelUpLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.LevelUpLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.LevelUpLog)
  return false;
#undef DO_
}

void LevelUpLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.LevelUpLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.LevelUpLog)
}

int LevelUpLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LevelUpLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LevelUpLog*>(&from));
}

void LevelUpLog::MergeFrom(const LevelUpLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LevelUpLog::CopyFrom(const LevelUpLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LevelUpLog::IsInitialized() const {

  return true;
}

void LevelUpLog::Swap(LevelUpLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LevelUpLog::GetTypeName() const {
  return "FpdLogMessage.LevelUpLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UseMagicLog_Use_magic_info_list::UseMagicLog_Use_magic_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

void UseMagicLog_Use_magic_info_list::InitAsDefaultInstance() {
}

UseMagicLog_Use_magic_info_list::UseMagicLog_Use_magic_info_list(const UseMagicLog_Use_magic_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

void UseMagicLog_Use_magic_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseMagicLog_Use_magic_info_list::~UseMagicLog_Use_magic_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.UseMagicLog.Use_magic_info_list)
  SharedDtor();
}

void UseMagicLog_Use_magic_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseMagicLog_Use_magic_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseMagicLog_Use_magic_info_list& UseMagicLog_Use_magic_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseMagicLog_Use_magic_info_list* UseMagicLog_Use_magic_info_list::default_instance_ = NULL;

UseMagicLog_Use_magic_info_list* UseMagicLog_Use_magic_info_list::New() const {
  return new UseMagicLog_Use_magic_info_list;
}

void UseMagicLog_Use_magic_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseMagicLog_Use_magic_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.UseMagicLog.Use_magic_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.UseMagicLog.Use_magic_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.UseMagicLog.Use_magic_info_list)
  return false;
#undef DO_
}

void UseMagicLog_Use_magic_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.UseMagicLog.Use_magic_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.UseMagicLog.Use_magic_info_list)
}

int UseMagicLog_Use_magic_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseMagicLog_Use_magic_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseMagicLog_Use_magic_info_list*>(&from));
}

void UseMagicLog_Use_magic_info_list::MergeFrom(const UseMagicLog_Use_magic_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseMagicLog_Use_magic_info_list::CopyFrom(const UseMagicLog_Use_magic_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseMagicLog_Use_magic_info_list::IsInitialized() const {

  return true;
}

void UseMagicLog_Use_magic_info_list::Swap(UseMagicLog_Use_magic_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseMagicLog_Use_magic_info_list::GetTypeName() const {
  return "FpdLogMessage.UseMagicLog.Use_magic_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

UseMagicLog::UseMagicLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.UseMagicLog)
}

void UseMagicLog::InitAsDefaultInstance() {
}

UseMagicLog::UseMagicLog(const UseMagicLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.UseMagicLog)
}

void UseMagicLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UseMagicLog::~UseMagicLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.UseMagicLog)
  SharedDtor();
}

void UseMagicLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UseMagicLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UseMagicLog& UseMagicLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

UseMagicLog* UseMagicLog::default_instance_ = NULL;

UseMagicLog* UseMagicLog::New() const {
  return new UseMagicLog;
}

void UseMagicLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UseMagicLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.UseMagicLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.UseMagicLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.UseMagicLog)
  return false;
#undef DO_
}

void UseMagicLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.UseMagicLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.UseMagicLog)
}

int UseMagicLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UseMagicLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UseMagicLog*>(&from));
}

void UseMagicLog::MergeFrom(const UseMagicLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UseMagicLog::CopyFrom(const UseMagicLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseMagicLog::IsInitialized() const {

  return true;
}

void UseMagicLog::Swap(UseMagicLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UseMagicLog::GetTypeName() const {
  return "FpdLogMessage.UseMagicLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

BrokenEquipmentLog::BrokenEquipmentLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.BrokenEquipmentLog)
}

void BrokenEquipmentLog::InitAsDefaultInstance() {
}

BrokenEquipmentLog::BrokenEquipmentLog(const BrokenEquipmentLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.BrokenEquipmentLog)
}

void BrokenEquipmentLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BrokenEquipmentLog::~BrokenEquipmentLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.BrokenEquipmentLog)
  SharedDtor();
}

void BrokenEquipmentLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BrokenEquipmentLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BrokenEquipmentLog& BrokenEquipmentLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

BrokenEquipmentLog* BrokenEquipmentLog::default_instance_ = NULL;

BrokenEquipmentLog* BrokenEquipmentLog::New() const {
  return new BrokenEquipmentLog;
}

void BrokenEquipmentLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool BrokenEquipmentLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.BrokenEquipmentLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.BrokenEquipmentLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.BrokenEquipmentLog)
  return false;
#undef DO_
}

void BrokenEquipmentLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.BrokenEquipmentLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.BrokenEquipmentLog)
}

int BrokenEquipmentLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BrokenEquipmentLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BrokenEquipmentLog*>(&from));
}

void BrokenEquipmentLog::MergeFrom(const BrokenEquipmentLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void BrokenEquipmentLog::CopyFrom(const BrokenEquipmentLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrokenEquipmentLog::IsInitialized() const {

  return true;
}

void BrokenEquipmentLog::Swap(BrokenEquipmentLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BrokenEquipmentLog::GetTypeName() const {
  return "FpdLogMessage.BrokenEquipmentLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PurchaseItemLog_Purchase_item_info_list::PurchaseItemLog_Purchase_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

void PurchaseItemLog_Purchase_item_info_list::InitAsDefaultInstance() {
}

PurchaseItemLog_Purchase_item_info_list::PurchaseItemLog_Purchase_item_info_list(const PurchaseItemLog_Purchase_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

void PurchaseItemLog_Purchase_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurchaseItemLog_Purchase_item_info_list::~PurchaseItemLog_Purchase_item_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  SharedDtor();
}

void PurchaseItemLog_Purchase_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PurchaseItemLog_Purchase_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PurchaseItemLog_Purchase_item_info_list& PurchaseItemLog_Purchase_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

PurchaseItemLog_Purchase_item_info_list* PurchaseItemLog_Purchase_item_info_list::default_instance_ = NULL;

PurchaseItemLog_Purchase_item_info_list* PurchaseItemLog_Purchase_item_info_list::New() const {
  return new PurchaseItemLog_Purchase_item_info_list;
}

void PurchaseItemLog_Purchase_item_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PurchaseItemLog_Purchase_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  return false;
#undef DO_
}

void PurchaseItemLog_Purchase_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.PurchaseItemLog.Purchase_item_info_list)
}

int PurchaseItemLog_Purchase_item_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurchaseItemLog_Purchase_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PurchaseItemLog_Purchase_item_info_list*>(&from));
}

void PurchaseItemLog_Purchase_item_info_list::MergeFrom(const PurchaseItemLog_Purchase_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PurchaseItemLog_Purchase_item_info_list::CopyFrom(const PurchaseItemLog_Purchase_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurchaseItemLog_Purchase_item_info_list::IsInitialized() const {

  return true;
}

void PurchaseItemLog_Purchase_item_info_list::Swap(PurchaseItemLog_Purchase_item_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PurchaseItemLog_Purchase_item_info_list::GetTypeName() const {
  return "FpdLogMessage.PurchaseItemLog.Purchase_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

PurchaseItemLog::PurchaseItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.PurchaseItemLog)
}

void PurchaseItemLog::InitAsDefaultInstance() {
}

PurchaseItemLog::PurchaseItemLog(const PurchaseItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.PurchaseItemLog)
}

void PurchaseItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurchaseItemLog::~PurchaseItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.PurchaseItemLog)
  SharedDtor();
}

void PurchaseItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PurchaseItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PurchaseItemLog& PurchaseItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

PurchaseItemLog* PurchaseItemLog::default_instance_ = NULL;

PurchaseItemLog* PurchaseItemLog::New() const {
  return new PurchaseItemLog;
}

void PurchaseItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PurchaseItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.PurchaseItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.PurchaseItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.PurchaseItemLog)
  return false;
#undef DO_
}

void PurchaseItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.PurchaseItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.PurchaseItemLog)
}

int PurchaseItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurchaseItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PurchaseItemLog*>(&from));
}

void PurchaseItemLog::MergeFrom(const PurchaseItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PurchaseItemLog::CopyFrom(const PurchaseItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurchaseItemLog::IsInitialized() const {

  return true;
}

void PurchaseItemLog::Swap(PurchaseItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PurchaseItemLog::GetTypeName() const {
  return "FpdLogMessage.PurchaseItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

DropItemLog_Throw_away_item_list::DropItemLog_Throw_away_item_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.DropItemLog.Throw_away_item_list)
}

void DropItemLog_Throw_away_item_list::InitAsDefaultInstance() {
}

DropItemLog_Throw_away_item_list::DropItemLog_Throw_away_item_list(const DropItemLog_Throw_away_item_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.DropItemLog.Throw_away_item_list)
}

void DropItemLog_Throw_away_item_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropItemLog_Throw_away_item_list::~DropItemLog_Throw_away_item_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.DropItemLog.Throw_away_item_list)
  SharedDtor();
}

void DropItemLog_Throw_away_item_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DropItemLog_Throw_away_item_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DropItemLog_Throw_away_item_list& DropItemLog_Throw_away_item_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

DropItemLog_Throw_away_item_list* DropItemLog_Throw_away_item_list::default_instance_ = NULL;

DropItemLog_Throw_away_item_list* DropItemLog_Throw_away_item_list::New() const {
  return new DropItemLog_Throw_away_item_list;
}

void DropItemLog_Throw_away_item_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DropItemLog_Throw_away_item_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.DropItemLog.Throw_away_item_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.DropItemLog.Throw_away_item_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.DropItemLog.Throw_away_item_list)
  return false;
#undef DO_
}

void DropItemLog_Throw_away_item_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.DropItemLog.Throw_away_item_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.DropItemLog.Throw_away_item_list)
}

int DropItemLog_Throw_away_item_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropItemLog_Throw_away_item_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropItemLog_Throw_away_item_list*>(&from));
}

void DropItemLog_Throw_away_item_list::MergeFrom(const DropItemLog_Throw_away_item_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DropItemLog_Throw_away_item_list::CopyFrom(const DropItemLog_Throw_away_item_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropItemLog_Throw_away_item_list::IsInitialized() const {

  return true;
}

void DropItemLog_Throw_away_item_list::Swap(DropItemLog_Throw_away_item_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DropItemLog_Throw_away_item_list::GetTypeName() const {
  return "FpdLogMessage.DropItemLog.Throw_away_item_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

DropItemLog::DropItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.DropItemLog)
}

void DropItemLog::InitAsDefaultInstance() {
}

DropItemLog::DropItemLog(const DropItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.DropItemLog)
}

void DropItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropItemLog::~DropItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.DropItemLog)
  SharedDtor();
}

void DropItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DropItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DropItemLog& DropItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

DropItemLog* DropItemLog::default_instance_ = NULL;

DropItemLog* DropItemLog::New() const {
  return new DropItemLog;
}

void DropItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DropItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.DropItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.DropItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.DropItemLog)
  return false;
#undef DO_
}

void DropItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.DropItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.DropItemLog)
}

int DropItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropItemLog*>(&from));
}

void DropItemLog::MergeFrom(const DropItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DropItemLog::CopyFrom(const DropItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropItemLog::IsInitialized() const {

  return true;
}

void DropItemLog::Swap(DropItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DropItemLog::GetTypeName() const {
  return "FpdLogMessage.DropItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

LeaveItemLog_Set_item_info_list::LeaveItemLog_Set_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

void LeaveItemLog_Set_item_info_list::InitAsDefaultInstance() {
}

LeaveItemLog_Set_item_info_list::LeaveItemLog_Set_item_info_list(const LeaveItemLog_Set_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

void LeaveItemLog_Set_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveItemLog_Set_item_info_list::~LeaveItemLog_Set_item_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.LeaveItemLog.Set_item_info_list)
  SharedDtor();
}

void LeaveItemLog_Set_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LeaveItemLog_Set_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveItemLog_Set_item_info_list& LeaveItemLog_Set_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LeaveItemLog_Set_item_info_list* LeaveItemLog_Set_item_info_list::default_instance_ = NULL;

LeaveItemLog_Set_item_info_list* LeaveItemLog_Set_item_info_list::New() const {
  return new LeaveItemLog_Set_item_info_list;
}

void LeaveItemLog_Set_item_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LeaveItemLog_Set_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.LeaveItemLog.Set_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.LeaveItemLog.Set_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.LeaveItemLog.Set_item_info_list)
  return false;
#undef DO_
}

void LeaveItemLog_Set_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.LeaveItemLog.Set_item_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.LeaveItemLog.Set_item_info_list)
}

int LeaveItemLog_Set_item_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveItemLog_Set_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveItemLog_Set_item_info_list*>(&from));
}

void LeaveItemLog_Set_item_info_list::MergeFrom(const LeaveItemLog_Set_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LeaveItemLog_Set_item_info_list::CopyFrom(const LeaveItemLog_Set_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveItemLog_Set_item_info_list::IsInitialized() const {

  return true;
}

void LeaveItemLog_Set_item_info_list::Swap(LeaveItemLog_Set_item_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveItemLog_Set_item_info_list::GetTypeName() const {
  return "FpdLogMessage.LeaveItemLog.Set_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

LeaveItemLog::LeaveItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.LeaveItemLog)
}

void LeaveItemLog::InitAsDefaultInstance() {
}

LeaveItemLog::LeaveItemLog(const LeaveItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.LeaveItemLog)
}

void LeaveItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveItemLog::~LeaveItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.LeaveItemLog)
  SharedDtor();
}

void LeaveItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LeaveItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LeaveItemLog& LeaveItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

LeaveItemLog* LeaveItemLog::default_instance_ = NULL;

LeaveItemLog* LeaveItemLog::New() const {
  return new LeaveItemLog;
}

void LeaveItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool LeaveItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.LeaveItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.LeaveItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.LeaveItemLog)
  return false;
#undef DO_
}

void LeaveItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.LeaveItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.LeaveItemLog)
}

int LeaveItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LeaveItemLog*>(&from));
}

void LeaveItemLog::MergeFrom(const LeaveItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void LeaveItemLog::CopyFrom(const LeaveItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveItemLog::IsInitialized() const {

  return true;
}

void LeaveItemLog::Swap(LeaveItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LeaveItemLog::GetTypeName() const {
  return "FpdLogMessage.LeaveItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

SaleItemLog_Sale_item_info_list::SaleItemLog_Sale_item_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

void SaleItemLog_Sale_item_info_list::InitAsDefaultInstance() {
}

SaleItemLog_Sale_item_info_list::SaleItemLog_Sale_item_info_list(const SaleItemLog_Sale_item_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

void SaleItemLog_Sale_item_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaleItemLog_Sale_item_info_list::~SaleItemLog_Sale_item_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.SaleItemLog.Sale_item_info_list)
  SharedDtor();
}

void SaleItemLog_Sale_item_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaleItemLog_Sale_item_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaleItemLog_Sale_item_info_list& SaleItemLog_Sale_item_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SaleItemLog_Sale_item_info_list* SaleItemLog_Sale_item_info_list::default_instance_ = NULL;

SaleItemLog_Sale_item_info_list* SaleItemLog_Sale_item_info_list::New() const {
  return new SaleItemLog_Sale_item_info_list;
}

void SaleItemLog_Sale_item_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SaleItemLog_Sale_item_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.SaleItemLog.Sale_item_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.SaleItemLog.Sale_item_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.SaleItemLog.Sale_item_info_list)
  return false;
#undef DO_
}

void SaleItemLog_Sale_item_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.SaleItemLog.Sale_item_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.SaleItemLog.Sale_item_info_list)
}

int SaleItemLog_Sale_item_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaleItemLog_Sale_item_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaleItemLog_Sale_item_info_list*>(&from));
}

void SaleItemLog_Sale_item_info_list::MergeFrom(const SaleItemLog_Sale_item_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SaleItemLog_Sale_item_info_list::CopyFrom(const SaleItemLog_Sale_item_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaleItemLog_Sale_item_info_list::IsInitialized() const {

  return true;
}

void SaleItemLog_Sale_item_info_list::Swap(SaleItemLog_Sale_item_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaleItemLog_Sale_item_info_list::GetTypeName() const {
  return "FpdLogMessage.SaleItemLog.Sale_item_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

SaleItemLog::SaleItemLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.SaleItemLog)
}

void SaleItemLog::InitAsDefaultInstance() {
}

SaleItemLog::SaleItemLog(const SaleItemLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.SaleItemLog)
}

void SaleItemLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaleItemLog::~SaleItemLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.SaleItemLog)
  SharedDtor();
}

void SaleItemLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SaleItemLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SaleItemLog& SaleItemLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

SaleItemLog* SaleItemLog::default_instance_ = NULL;

SaleItemLog* SaleItemLog::New() const {
  return new SaleItemLog;
}

void SaleItemLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool SaleItemLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.SaleItemLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.SaleItemLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.SaleItemLog)
  return false;
#undef DO_
}

void SaleItemLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.SaleItemLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.SaleItemLog)
}

int SaleItemLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaleItemLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SaleItemLog*>(&from));
}

void SaleItemLog::MergeFrom(const SaleItemLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void SaleItemLog::CopyFrom(const SaleItemLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaleItemLog::IsInitialized() const {

  return true;
}

void SaleItemLog::Swap(SaleItemLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SaleItemLog::GetTypeName() const {
  return "FpdLogMessage.SaleItemLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

AccessWarehouseLog_Access_warehouse_info_list::AccessWarehouseLog_Access_warehouse_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

void AccessWarehouseLog_Access_warehouse_info_list::InitAsDefaultInstance() {
}

AccessWarehouseLog_Access_warehouse_info_list::AccessWarehouseLog_Access_warehouse_info_list(const AccessWarehouseLog_Access_warehouse_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

void AccessWarehouseLog_Access_warehouse_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessWarehouseLog_Access_warehouse_info_list::~AccessWarehouseLog_Access_warehouse_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  SharedDtor();
}

void AccessWarehouseLog_Access_warehouse_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AccessWarehouseLog_Access_warehouse_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AccessWarehouseLog_Access_warehouse_info_list& AccessWarehouseLog_Access_warehouse_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

AccessWarehouseLog_Access_warehouse_info_list* AccessWarehouseLog_Access_warehouse_info_list::default_instance_ = NULL;

AccessWarehouseLog_Access_warehouse_info_list* AccessWarehouseLog_Access_warehouse_info_list::New() const {
  return new AccessWarehouseLog_Access_warehouse_info_list;
}

void AccessWarehouseLog_Access_warehouse_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AccessWarehouseLog_Access_warehouse_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  return false;
#undef DO_
}

void AccessWarehouseLog_Access_warehouse_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list)
}

int AccessWarehouseLog_Access_warehouse_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessWarehouseLog_Access_warehouse_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AccessWarehouseLog_Access_warehouse_info_list*>(&from));
}

void AccessWarehouseLog_Access_warehouse_info_list::MergeFrom(const AccessWarehouseLog_Access_warehouse_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AccessWarehouseLog_Access_warehouse_info_list::CopyFrom(const AccessWarehouseLog_Access_warehouse_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessWarehouseLog_Access_warehouse_info_list::IsInitialized() const {

  return true;
}

void AccessWarehouseLog_Access_warehouse_info_list::Swap(AccessWarehouseLog_Access_warehouse_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AccessWarehouseLog_Access_warehouse_info_list::GetTypeName() const {
  return "FpdLogMessage.AccessWarehouseLog.Access_warehouse_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

AccessWarehouseLog::AccessWarehouseLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.AccessWarehouseLog)
}

void AccessWarehouseLog::InitAsDefaultInstance() {
}

AccessWarehouseLog::AccessWarehouseLog(const AccessWarehouseLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.AccessWarehouseLog)
}

void AccessWarehouseLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccessWarehouseLog::~AccessWarehouseLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.AccessWarehouseLog)
  SharedDtor();
}

void AccessWarehouseLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AccessWarehouseLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AccessWarehouseLog& AccessWarehouseLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

AccessWarehouseLog* AccessWarehouseLog::default_instance_ = NULL;

AccessWarehouseLog* AccessWarehouseLog::New() const {
  return new AccessWarehouseLog;
}

void AccessWarehouseLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool AccessWarehouseLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.AccessWarehouseLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.AccessWarehouseLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.AccessWarehouseLog)
  return false;
#undef DO_
}

void AccessWarehouseLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.AccessWarehouseLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.AccessWarehouseLog)
}

int AccessWarehouseLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccessWarehouseLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AccessWarehouseLog*>(&from));
}

void AccessWarehouseLog::MergeFrom(const AccessWarehouseLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void AccessWarehouseLog::CopyFrom(const AccessWarehouseLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccessWarehouseLog::IsInitialized() const {

  return true;
}

void AccessWarehouseLog::Swap(AccessWarehouseLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AccessWarehouseLog::GetTypeName() const {
  return "FpdLogMessage.AccessWarehouseLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

StrengthenWeaponLog_Strengthen_weapon_info_list::StrengthenWeaponLog_Strengthen_weapon_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::InitAsDefaultInstance() {
}

StrengthenWeaponLog_Strengthen_weapon_info_list::StrengthenWeaponLog_Strengthen_weapon_info_list(const StrengthenWeaponLog_Strengthen_weapon_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthenWeaponLog_Strengthen_weapon_info_list::~StrengthenWeaponLog_Strengthen_weapon_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  SharedDtor();
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthenWeaponLog_Strengthen_weapon_info_list& StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

StrengthenWeaponLog_Strengthen_weapon_info_list* StrengthenWeaponLog_Strengthen_weapon_info_list::default_instance_ = NULL;

StrengthenWeaponLog_Strengthen_weapon_info_list* StrengthenWeaponLog_Strengthen_weapon_info_list::New() const {
  return new StrengthenWeaponLog_Strengthen_weapon_info_list;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StrengthenWeaponLog_Strengthen_weapon_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  return false;
#undef DO_
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list)
}

int StrengthenWeaponLog_Strengthen_weapon_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthenWeaponLog_Strengthen_weapon_info_list*>(&from));
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::MergeFrom(const StrengthenWeaponLog_Strengthen_weapon_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::CopyFrom(const StrengthenWeaponLog_Strengthen_weapon_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthenWeaponLog_Strengthen_weapon_info_list::IsInitialized() const {

  return true;
}

void StrengthenWeaponLog_Strengthen_weapon_info_list::Swap(StrengthenWeaponLog_Strengthen_weapon_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthenWeaponLog_Strengthen_weapon_info_list::GetTypeName() const {
  return "FpdLogMessage.StrengthenWeaponLog.Strengthen_weapon_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

StrengthenWeaponLog::StrengthenWeaponLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.StrengthenWeaponLog)
}

void StrengthenWeaponLog::InitAsDefaultInstance() {
}

StrengthenWeaponLog::StrengthenWeaponLog(const StrengthenWeaponLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.StrengthenWeaponLog)
}

void StrengthenWeaponLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrengthenWeaponLog::~StrengthenWeaponLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.StrengthenWeaponLog)
  SharedDtor();
}

void StrengthenWeaponLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StrengthenWeaponLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StrengthenWeaponLog& StrengthenWeaponLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

StrengthenWeaponLog* StrengthenWeaponLog::default_instance_ = NULL;

StrengthenWeaponLog* StrengthenWeaponLog::New() const {
  return new StrengthenWeaponLog;
}

void StrengthenWeaponLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool StrengthenWeaponLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.StrengthenWeaponLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.StrengthenWeaponLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.StrengthenWeaponLog)
  return false;
#undef DO_
}

void StrengthenWeaponLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.StrengthenWeaponLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.StrengthenWeaponLog)
}

int StrengthenWeaponLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrengthenWeaponLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StrengthenWeaponLog*>(&from));
}

void StrengthenWeaponLog::MergeFrom(const StrengthenWeaponLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void StrengthenWeaponLog::CopyFrom(const StrengthenWeaponLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrengthenWeaponLog::IsInitialized() const {

  return true;
}

void StrengthenWeaponLog::Swap(StrengthenWeaponLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StrengthenWeaponLog::GetTypeName() const {
  return "FpdLogMessage.StrengthenWeaponLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

RepairEquipmentLog_Repair_equipment_info_list::RepairEquipmentLog_Repair_equipment_info_list()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

void RepairEquipmentLog_Repair_equipment_info_list::InitAsDefaultInstance() {
}

RepairEquipmentLog_Repair_equipment_info_list::RepairEquipmentLog_Repair_equipment_info_list(const RepairEquipmentLog_Repair_equipment_info_list& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

void RepairEquipmentLog_Repair_equipment_info_list::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RepairEquipmentLog_Repair_equipment_info_list::~RepairEquipmentLog_Repair_equipment_info_list() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  SharedDtor();
}

void RepairEquipmentLog_Repair_equipment_info_list::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RepairEquipmentLog_Repair_equipment_info_list::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RepairEquipmentLog_Repair_equipment_info_list& RepairEquipmentLog_Repair_equipment_info_list::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

RepairEquipmentLog_Repair_equipment_info_list* RepairEquipmentLog_Repair_equipment_info_list::default_instance_ = NULL;

RepairEquipmentLog_Repair_equipment_info_list* RepairEquipmentLog_Repair_equipment_info_list::New() const {
  return new RepairEquipmentLog_Repair_equipment_info_list;
}

void RepairEquipmentLog_Repair_equipment_info_list::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RepairEquipmentLog_Repair_equipment_info_list::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  return false;
#undef DO_
}

void RepairEquipmentLog_Repair_equipment_info_list::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list)
}

int RepairEquipmentLog_Repair_equipment_info_list::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RepairEquipmentLog_Repair_equipment_info_list::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RepairEquipmentLog_Repair_equipment_info_list*>(&from));
}

void RepairEquipmentLog_Repair_equipment_info_list::MergeFrom(const RepairEquipmentLog_Repair_equipment_info_list& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RepairEquipmentLog_Repair_equipment_info_list::CopyFrom(const RepairEquipmentLog_Repair_equipment_info_list& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepairEquipmentLog_Repair_equipment_info_list::IsInitialized() const {

  return true;
}

void RepairEquipmentLog_Repair_equipment_info_list::Swap(RepairEquipmentLog_Repair_equipment_info_list* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RepairEquipmentLog_Repair_equipment_info_list::GetTypeName() const {
  return "FpdLogMessage.RepairEquipmentLog.Repair_equipment_info_list";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

RepairEquipmentLog::RepairEquipmentLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.RepairEquipmentLog)
}

void RepairEquipmentLog::InitAsDefaultInstance() {
}

RepairEquipmentLog::RepairEquipmentLog(const RepairEquipmentLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.RepairEquipmentLog)
}

void RepairEquipmentLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RepairEquipmentLog::~RepairEquipmentLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.RepairEquipmentLog)
  SharedDtor();
}

void RepairEquipmentLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RepairEquipmentLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RepairEquipmentLog& RepairEquipmentLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

RepairEquipmentLog* RepairEquipmentLog::default_instance_ = NULL;

RepairEquipmentLog* RepairEquipmentLog::New() const {
  return new RepairEquipmentLog;
}

void RepairEquipmentLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool RepairEquipmentLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.RepairEquipmentLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.RepairEquipmentLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.RepairEquipmentLog)
  return false;
#undef DO_
}

void RepairEquipmentLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.RepairEquipmentLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.RepairEquipmentLog)
}

int RepairEquipmentLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RepairEquipmentLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RepairEquipmentLog*>(&from));
}

void RepairEquipmentLog::MergeFrom(const RepairEquipmentLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void RepairEquipmentLog::CopyFrom(const RepairEquipmentLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RepairEquipmentLog::IsInitialized() const {

  return true;
}

void RepairEquipmentLog::Swap(RepairEquipmentLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RepairEquipmentLog::GetTypeName() const {
  return "FpdLogMessage.RepairEquipmentLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EquipMagicLog::EquipMagicLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.EquipMagicLog)
}

void EquipMagicLog::InitAsDefaultInstance() {
}

EquipMagicLog::EquipMagicLog(const EquipMagicLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.EquipMagicLog)
}

void EquipMagicLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EquipMagicLog::~EquipMagicLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.EquipMagicLog)
  SharedDtor();
}

void EquipMagicLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EquipMagicLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EquipMagicLog& EquipMagicLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

EquipMagicLog* EquipMagicLog::default_instance_ = NULL;

EquipMagicLog* EquipMagicLog::New() const {
  return new EquipMagicLog;
}

void EquipMagicLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool EquipMagicLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.EquipMagicLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.EquipMagicLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.EquipMagicLog)
  return false;
#undef DO_
}

void EquipMagicLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.EquipMagicLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.EquipMagicLog)
}

int EquipMagicLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EquipMagicLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EquipMagicLog*>(&from));
}

void EquipMagicLog::MergeFrom(const EquipMagicLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EquipMagicLog::CopyFrom(const EquipMagicLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EquipMagicLog::IsInitialized() const {

  return true;
}

void EquipMagicLog::Swap(EquipMagicLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EquipMagicLog::GetTypeName() const {
  return "FpdLogMessage.EquipMagicLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ChaneEstusFlaskNumLog::ChaneEstusFlaskNumLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.ChaneEstusFlaskNumLog)
}

void ChaneEstusFlaskNumLog::InitAsDefaultInstance() {
}

ChaneEstusFlaskNumLog::ChaneEstusFlaskNumLog(const ChaneEstusFlaskNumLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.ChaneEstusFlaskNumLog)
}

void ChaneEstusFlaskNumLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChaneEstusFlaskNumLog::~ChaneEstusFlaskNumLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.ChaneEstusFlaskNumLog)
  SharedDtor();
}

void ChaneEstusFlaskNumLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChaneEstusFlaskNumLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChaneEstusFlaskNumLog& ChaneEstusFlaskNumLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ChaneEstusFlaskNumLog* ChaneEstusFlaskNumLog::default_instance_ = NULL;

ChaneEstusFlaskNumLog* ChaneEstusFlaskNumLog::New() const {
  return new ChaneEstusFlaskNumLog;
}

void ChaneEstusFlaskNumLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ChaneEstusFlaskNumLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.ChaneEstusFlaskNumLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.ChaneEstusFlaskNumLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.ChaneEstusFlaskNumLog)
  return false;
#undef DO_
}

void ChaneEstusFlaskNumLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.ChaneEstusFlaskNumLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.ChaneEstusFlaskNumLog)
}

int ChaneEstusFlaskNumLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChaneEstusFlaskNumLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChaneEstusFlaskNumLog*>(&from));
}

void ChaneEstusFlaskNumLog::MergeFrom(const ChaneEstusFlaskNumLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ChaneEstusFlaskNumLog::CopyFrom(const ChaneEstusFlaskNumLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChaneEstusFlaskNumLog::IsInitialized() const {

  return true;
}

void ChaneEstusFlaskNumLog::Swap(ChaneEstusFlaskNumLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChaneEstusFlaskNumLog::GetTypeName() const {
  return "FpdLogMessage.ChaneEstusFlaskNumLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CreateBloodMessageLog::CreateBloodMessageLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.CreateBloodMessageLog)
}

void CreateBloodMessageLog::InitAsDefaultInstance() {
}

CreateBloodMessageLog::CreateBloodMessageLog(const CreateBloodMessageLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.CreateBloodMessageLog)
}

void CreateBloodMessageLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateBloodMessageLog::~CreateBloodMessageLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.CreateBloodMessageLog)
  SharedDtor();
}

void CreateBloodMessageLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateBloodMessageLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateBloodMessageLog& CreateBloodMessageLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

CreateBloodMessageLog* CreateBloodMessageLog::default_instance_ = NULL;

CreateBloodMessageLog* CreateBloodMessageLog::New() const {
  return new CreateBloodMessageLog;
}

void CreateBloodMessageLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CreateBloodMessageLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.CreateBloodMessageLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.CreateBloodMessageLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.CreateBloodMessageLog)
  return false;
#undef DO_
}

void CreateBloodMessageLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.CreateBloodMessageLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.CreateBloodMessageLog)
}

int CreateBloodMessageLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateBloodMessageLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateBloodMessageLog*>(&from));
}

void CreateBloodMessageLog::MergeFrom(const CreateBloodMessageLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CreateBloodMessageLog::CopyFrom(const CreateBloodMessageLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateBloodMessageLog::IsInitialized() const {

  return true;
}

void CreateBloodMessageLog::Swap(CreateBloodMessageLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateBloodMessageLog::GetTypeName() const {
  return "FpdLogMessage.CreateBloodMessageLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EvaluateBloodMessageLog::EvaluateBloodMessageLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.EvaluateBloodMessageLog)
}

void EvaluateBloodMessageLog::InitAsDefaultInstance() {
}

EvaluateBloodMessageLog::EvaluateBloodMessageLog(const EvaluateBloodMessageLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.EvaluateBloodMessageLog)
}

void EvaluateBloodMessageLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EvaluateBloodMessageLog::~EvaluateBloodMessageLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.EvaluateBloodMessageLog)
  SharedDtor();
}

void EvaluateBloodMessageLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EvaluateBloodMessageLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EvaluateBloodMessageLog& EvaluateBloodMessageLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

EvaluateBloodMessageLog* EvaluateBloodMessageLog::default_instance_ = NULL;

EvaluateBloodMessageLog* EvaluateBloodMessageLog::New() const {
  return new EvaluateBloodMessageLog;
}

void EvaluateBloodMessageLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool EvaluateBloodMessageLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.EvaluateBloodMessageLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.EvaluateBloodMessageLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.EvaluateBloodMessageLog)
  return false;
#undef DO_
}

void EvaluateBloodMessageLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.EvaluateBloodMessageLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.EvaluateBloodMessageLog)
}

int EvaluateBloodMessageLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EvaluateBloodMessageLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EvaluateBloodMessageLog*>(&from));
}

void EvaluateBloodMessageLog::MergeFrom(const EvaluateBloodMessageLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void EvaluateBloodMessageLog::CopyFrom(const EvaluateBloodMessageLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvaluateBloodMessageLog::IsInitialized() const {

  return true;
}

void EvaluateBloodMessageLog::Swap(EvaluateBloodMessageLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EvaluateBloodMessageLog::GetTypeName() const {
  return "FpdLogMessage.EvaluateBloodMessageLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

VisitResultLog::VisitResultLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.VisitResultLog)
}

void VisitResultLog::InitAsDefaultInstance() {
}

VisitResultLog::VisitResultLog(const VisitResultLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.VisitResultLog)
}

void VisitResultLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VisitResultLog::~VisitResultLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.VisitResultLog)
  SharedDtor();
}

void VisitResultLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VisitResultLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VisitResultLog& VisitResultLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

VisitResultLog* VisitResultLog::default_instance_ = NULL;

VisitResultLog* VisitResultLog::New() const {
  return new VisitResultLog;
}

void VisitResultLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool VisitResultLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.VisitResultLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.VisitResultLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.VisitResultLog)
  return false;
#undef DO_
}

void VisitResultLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.VisitResultLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.VisitResultLog)
}

int VisitResultLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VisitResultLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VisitResultLog*>(&from));
}

void VisitResultLog::MergeFrom(const VisitResultLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void VisitResultLog::CopyFrom(const VisitResultLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VisitResultLog::IsInitialized() const {

  return true;
}

void VisitResultLog::Swap(VisitResultLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VisitResultLog::GetTypeName() const {
  return "FpdLogMessage.VisitResultLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

QuickMatchResultLog::QuickMatchResultLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.QuickMatchResultLog)
}

void QuickMatchResultLog::InitAsDefaultInstance() {
}

QuickMatchResultLog::QuickMatchResultLog(const QuickMatchResultLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.QuickMatchResultLog)
}

void QuickMatchResultLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchResultLog::~QuickMatchResultLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.QuickMatchResultLog)
  SharedDtor();
}

void QuickMatchResultLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchResultLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchResultLog& QuickMatchResultLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchResultLog* QuickMatchResultLog::default_instance_ = NULL;

QuickMatchResultLog* QuickMatchResultLog::New() const {
  return new QuickMatchResultLog;
}

void QuickMatchResultLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchResultLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.QuickMatchResultLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.QuickMatchResultLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.QuickMatchResultLog)
  return false;
#undef DO_
}

void QuickMatchResultLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.QuickMatchResultLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.QuickMatchResultLog)
}

int QuickMatchResultLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchResultLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchResultLog*>(&from));
}

void QuickMatchResultLog::MergeFrom(const QuickMatchResultLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchResultLog::CopyFrom(const QuickMatchResultLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchResultLog::IsInitialized() const {

  return true;
}

void QuickMatchResultLog::Swap(QuickMatchResultLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchResultLog::GetTypeName() const {
  return "FpdLogMessage.QuickMatchResultLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

QuickMatchEndLog::QuickMatchEndLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.QuickMatchEndLog)
}

void QuickMatchEndLog::InitAsDefaultInstance() {
}

QuickMatchEndLog::QuickMatchEndLog(const QuickMatchEndLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.QuickMatchEndLog)
}

void QuickMatchEndLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QuickMatchEndLog::~QuickMatchEndLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.QuickMatchEndLog)
  SharedDtor();
}

void QuickMatchEndLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QuickMatchEndLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QuickMatchEndLog& QuickMatchEndLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

QuickMatchEndLog* QuickMatchEndLog::default_instance_ = NULL;

QuickMatchEndLog* QuickMatchEndLog::New() const {
  return new QuickMatchEndLog;
}

void QuickMatchEndLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool QuickMatchEndLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.QuickMatchEndLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.QuickMatchEndLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.QuickMatchEndLog)
  return false;
#undef DO_
}

void QuickMatchEndLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.QuickMatchEndLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.QuickMatchEndLog)
}

int QuickMatchEndLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QuickMatchEndLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QuickMatchEndLog*>(&from));
}

void QuickMatchEndLog::MergeFrom(const QuickMatchEndLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void QuickMatchEndLog::CopyFrom(const QuickMatchEndLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuickMatchEndLog::IsInitialized() const {

  return true;
}

void QuickMatchEndLog::Swap(QuickMatchEndLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string QuickMatchEndLog::GetTypeName() const {
  return "FpdLogMessage.QuickMatchEndLog";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ConvertSaveDataLog::ConvertSaveDataLog()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:FpdLogMessage.ConvertSaveDataLog)
}

void ConvertSaveDataLog::InitAsDefaultInstance() {
}

ConvertSaveDataLog::ConvertSaveDataLog(const ConvertSaveDataLog& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:FpdLogMessage.ConvertSaveDataLog)
}

void ConvertSaveDataLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConvertSaveDataLog::~ConvertSaveDataLog() {
  // @@protoc_insertion_point(destructor:FpdLogMessage.ConvertSaveDataLog)
  SharedDtor();
}

void ConvertSaveDataLog::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConvertSaveDataLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConvertSaveDataLog& ConvertSaveDataLog::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_FpdLogMessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_FpdLogMessage_2eproto();
#endif
  return *default_instance_;
}

ConvertSaveDataLog* ConvertSaveDataLog::default_instance_ = NULL;

ConvertSaveDataLog* ConvertSaveDataLog::New() const {
  return new ConvertSaveDataLog;
}

void ConvertSaveDataLog::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ConvertSaveDataLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:FpdLogMessage.ConvertSaveDataLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:FpdLogMessage.ConvertSaveDataLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:FpdLogMessage.ConvertSaveDataLog)
  return false;
#undef DO_
}

void ConvertSaveDataLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:FpdLogMessage.ConvertSaveDataLog)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:FpdLogMessage.ConvertSaveDataLog)
}

int ConvertSaveDataLog::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConvertSaveDataLog::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConvertSaveDataLog*>(&from));
}

void ConvertSaveDataLog::MergeFrom(const ConvertSaveDataLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ConvertSaveDataLog::CopyFrom(const ConvertSaveDataLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvertSaveDataLog::IsInitialized() const {

  return true;
}

void ConvertSaveDataLog::Swap(ConvertSaveDataLog* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConvertSaveDataLog::GetTypeName() const {
  return "FpdLogMessage.ConvertSaveDataLog";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FpdLogMessage

// @@protoc_insertion_point(global_scope)
